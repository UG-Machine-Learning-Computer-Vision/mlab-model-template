"""
Do not edit this file
This is the file that will be used to test your model
"""
import os
import argparse
import json
import requests
from dotenv import load_dotenv
from model import test as test_model
from __utils__ import fetch_parameters

load_dotenv()
if __name__ == "__main__":
  # Run the model, pass the file location, the file type and the dataset name
  # Where inputs would be from command line
    print("Running model")
    parser=argparse.ArgumentParser(
        description="test a model",
        prog="maldec-test",
    )

    parser.add_argument(
        "--config",
        type=str,
        help="Path to config file",
        required=False,
    )

    parser.add_argument(
        "--result_id",
        type=str,
        help="Result ID",
    )

    parser.add_argument(
        "--trained_model",
        type=str,
        help="Trained model path",
    )

    args=parser.parse_args()

    CONFIG_PATH = args.config
    result_id = args.result_id
    trained_model = args.trained_model
    if CONFIG_PATH is None:
        CONFIG_PATH = "config.txt" # type: ignore
    parameters = fetch_parameters(config_path=CONFIG_PATH)
    DATASET_PATH = str(parameters["dataset_url"]).strip() # type: ignore

    test_error = False

    # Get API URL from .env file
    API_URL = str(os.getenv("MLAB_API_URL")) + "/test"

    # check if trained model exists
    if not os.path.exists(trained_model):
        raise ValueError("Trained model not found")


    if API_URL is None:
        raise ValueError("API_URL not found in .env file")
    try:
        
        model = test_model(dataset_path=DATASET_PATH, result_id=result_id, model_path=trained_model)

        
        files = {}

        for file in model.files:
            filename = file.split("/")[-1]
            files[filename] = (filename, open(file, 'rb'))

        # Stringify metrics
        metrics = json.dumps(model.metrics)
        data = {
            "result_id": result_id,
            "metrics": metrics,
            "predictions": model.predictions,
        }


        response = requests.post(API_URL, data=data, files=files,timeout=120)

        if response.status_code == 200:
            print("Successfully uploaded results")
            for file in model.files:
                os.remove(file)
        else:
            print("Error uploading results")
            # Append error in error.txt file
            # First check if error.txt file exists
            raise requests.HTTPError(f"Error uploading results. Status code: {response.status_code}, error: {response.text}")

    except Exception as e:
        # Append error in error.txt file
        # First check if error.txt file exists
        if not os.path.exists(f"{result_id}/error.txt"):
            with open(f"{result_id}/error.txt", "w", encoding="utf-8") as f:
                f.write(str(e))
        else:
            with open(f"{result_id}/error.txt", "a", encoding="utf-8") as f:
                f.write(str(e))
        error_file = open(f"{result_id}/error.txt", "rb")
        req_files = {
            "error.txt": error_file,
        }
        requests.post(API_URL+f"?error={True}", data={"result_id": result_id, "error": str(e)}, files=req_files, timeout=120)
